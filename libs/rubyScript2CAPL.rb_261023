require_relative 'version.rb'
require_relative 'syntaxPTW.rb'

module RubyScript2CAPL

class LexicalAnalyzer
  attr_accessor :keywords, :error, :errorList, :specialChar
  attr_accessor :includeFiles, :functionNames, :variableNames

  def initialize()
    puts "Script lexical converter version #{VERSIONLEXICALCONVERTER} Initialized"
    @file2Convert_name = ""
    @debugLexical = false
    @keywords = Syntax.new()
    @includeFiles = Array.new
    @functionNames = Hash.new # {"functionName" => {0 => "param1", 1 => "param2"}
    @variableNames = Array.new
    @error = Hash.new #{ "Error Name" => {0 => "Linenumber",     1 => "whatkindoferror",       2 => "awaiting values are"               }
                      #    generated         codeGenerated      key@errorList=>0 or 1       generated based on relations
    @errorList = {0 => "not a relationship", 1 => "forbidenRelation" }
    @specialChar = [
                      "(", 
                      ")",
                      "[",
                      "]",
                      "{",
                      "}",
                      ";",
                      ":",
                      ",",
                      ".",
                      "\"",
                      "'",
                      "_",
                      "-",
                      "+",
                      "=",
                      "?",
                      " ",
                      "#",
                      "|",
                      "<",
                      ">",
                      "\/",
                      "\\",
                      "~",
                      "!",
                      "@",
                      "$",
                      "%",
                      "^",
                      "&",
                      "*",
                      "\n",
                      "\t",
                      "\r"
                   ]
  end

  def activateLexicalDebugger
    @debugLexical = true
  end
  
  def setTranslatedFileName(fileTranslatedName)
    @file2Convert_name = fileTranslatedName
  end

  def getTranslatedFileName()
    return @file2Convert_name
  end
  
  def lexycalChecker(file2Convert)
    puts "Script lexical converter Started"    
    setTranslatedFileName("#{file2Convert}.translated")
    parseAndTranslateToSyntaxSimbols(file2Convert)
    puts "Script lexical converter Done"
  end
  
  def toggle(variable)
    if (variable)
      return false
    else
      return true
    end
  end

  def parseAndTranslateToSyntaxSimbols(file2Convert)
    typeOfToken = "K_NA" #Keyword notAvailable  
    typeOfOperand = "O_NA" #Operand notAvailable  
    typeOfRelation = "R_NA" #Relationship notAvailable  
    
    openCloseCompound = 0;
    openCloseBraket = 0;
    openCloseParant = 0;
    openCloseBraces = 0;
    compoundVariable = Array.new
          
    fileContent = File.open(file2Convert).read
    tempFileContent = File.open(@file2Convert_name,"w")
    
    fileContent.gsub!(/\r\n?/,"\n")
      
    fileContent.each_line do |line|
      charsFromLine = line.split("")
        
      word = ""
      wordLast = ""
      word2Special = false
      special2Word = false
      specialWord = ""
      specialWordLast = "" 
      haveWord = false
      haveWordOldState = haveWord
      gotoNextLine = false
      currentToken = "T_NA"
      isCompound = false
      isParanthesis = false
      isBraket = false
      isBraces = false
      operandWord = ""
        
      charsFromLine.each_with_index.map do |chr, chr_idx|
        if !specialChar.include?(chr)
          if !operandWord.empty?
            operandFound = @keywords.isOperand?(operandWord)
            if operandFound != "O_NA" and (word.empty?)
              tempFileContent.write("#{operandFound} ")
              operandWord = ""
            end
          end
          word = word + chr
        elsif specialChar.include?(chr)
          case chr
          when ' ', "\n", "\t", "\r" #new word?
            if !word.empty? and openCloseCompound == 0
              typeOfToken = @keywords.isToken?(word)
              if (typeOfToken != "T_NA")
                tempFileContent.write("#{typeOfToken} ")
              else
                if isCompound
                  tempFileContent.write("S_VALUE #{word} ")
                else
                  if @keywords.isNumeric?(word)
                    tempFileContent.write("N_VALUE #{word} ")
                  elsif @keywords.isAlphaNumeric?(word)
                    tempFileContent.write("I_VALUE #{word} ")
                  end
                end
              end
              wordLast = word
              word = ""
            elsif openCloseCompound > 0
              word = word + chr
            end
            operandFound = @keywords.isOperand?(operandWord)
            if operandFound != "O_NA" and (word.empty?)
              tempFileContent.write("#{operandFound} ")
              operandWord = ""
            end 
          when '"'
            if ['~', '^', '!', '+', '-', '%', '/', '*','>','<','=','&','|','(', ',', '[', ']', ')', '{', '}',';'].include? operandWord
              operandFound = @keywords.isOperand?(operandWord)
              if operandFound != "O_NA" and (word.empty?)
                tempFileContent.write("#{operandFound} ")
                operandWord = ""
              end 
            end
            operandWord = operandWord + chr
            openCloseCompound = openCloseCompound + 1
            if ( (openCloseCompound % 2) == 0 )
              isCompound = true
              openCloseCompound = 0
              tempFileContent.write("S_VALUE #{word} ")
              operandFound = @keywords.isOperand?(operandWord)
              tempFileContent.write("#{operandFound} ")
              operandWord = ""
              wordLast = word
              word = ""
            end
          when '#'
            if !word.empty? and openCloseCompound == 0
              typeOfToken = @keywords.isToken?(word)
              if (typeOfToken != "T_NA")
                tempFileContent.write("#{typeOfToken} ")
              else
                if isCompound
                  tempFileContent.write("S_VALUE #{word} ")
                else
                  if @keywords.isNumeric?(word)
                    tempFileContent.write("N_VALUE #{word} ")
                  elsif @keywords.isAlphaNumeric?(word)
                    tempFileContent.write("I_VALUE #{word} ")
                  end
                end
              end
              wordLast = word
              word = ""
            elsif openCloseCompound > 0
              word = word + chr
            end
            if openCloseCompound == 0
              break
            end
          when '(', ',', '[', ']', ')', '{', '}',';'
            if !operandWord.empty?
              operandFound = @keywords.isOperand?(operandWord)
              if operandFound != "O_NA" and (word.empty?)
                tempFileContent.write("#{operandFound} ")
                operandWord = ""
              end
            end
            operandWord = operandWord + chr
            if !word.empty? and openCloseCompound == 0
              typeOfToken = @keywords.isToken?(word)
              if (typeOfToken != "T_NA")
                tempFileContent.write("#{typeOfToken} ")
              else
                if isCompound
                  tempFileContent.write("S_VALUE #{word} ")
                else
                  if @keywords.isNumeric?(word)
                    tempFileContent.write("N_VALUE #{word} ")
                  elsif @keywords.isAlphaNumeric?(word)
                    tempFileContent.write("I_VALUE #{word} ")
                  end
                end
              end
              wordLast = word
              word = ""
            elsif openCloseCompound > 0
              word = word + chr
            end
          when '~', ':', '^', '!', '+', '-', '%', '/', '*','>','<','=','&','|'
            
            if !operandWord.empty? and operandWord.include? ")"
              operandFound = @keywords.isOperand?(operandWord)
              if operandFound != "O_NA" and (word.empty?)
                tempFileContent.write("#{operandFound} ")
                operandWord = ""
              end
            end
            operandWord = operandWord + chr
            if !word.empty? and openCloseCompound == 0
              typeOfToken = @keywords.isToken?(word)
              if (typeOfToken != "T_NA")
                tempFileContent.write("#{typeOfToken} ")
              else
                if isCompound
                  tempFileContent.write("S_VALUE #{word} ")
                else
                  if @keywords.isNumeric?(word)
                    tempFileContent.write("N_VALUE #{word} ")
                  elsif @keywords.isAlphaNumeric?(word)
                    tempFileContent.write("I_VALUE #{word} ")
                  end
                end
              end
              wordLast = word
              word = ""
            elsif openCloseCompound > 0
              word = word + chr
            end
          when '.'
            if @keywords.isTypeOfToken(typeOfToken)
              word = word + chr
            else 
              operandWord = operandWord + chr
            end
          end
        end
      end # charsFromLine.each_with_index.map do |chr, chr_idx|
      tempFileContent.write("\n")
    end
    tempFileContent.close
  end

end #class Converter

class SyntaxAnalyzer
  attr_accessor :keywords, :error, :errorList, :specialChar
  attr_accessor :includeFiles, :functionNames, :variableNames

  def initialize()
    puts "Script syntax checker version #{VERSIONSYNTAXCHECKER} Initialized"
    @syntax = Syntax.new()
    @debugSyntax = false
    @includeFiles = Array.new
    @functionNames = Hash.new # {"functionName" => {0 => "param1", 1 => "param2"}
    @variableNames = Array.new # {"variableName1", "variableName2", etc.}
    @error = Hash.new #{ "Error Name" => {0 => "Linenumber",     1 => "whatkindoferror",       2 => "awaiting values are"               }
                      #    generated         codeGenerated      key@errorList=>0 or 1       generated based on relations
    @errorList = {0 => "not a relationship", 1 => "forbidenRelation" }
    @fileName = ""
    @tempFileContent = ""
  end

  def activateSyntaxDebugger
    @debugSyntax = true
  end

  def findWordInRelationShip(word, relationShips_, atPosition)
    if relationShips_.values[atPosition].is_a?(Hash)
    #relationShips_.each do |relation_key, relations|
      relationShips_.values[atPosition].each_with_index do |(relation_key, relations), index|
        if (relations.is_a?(Hash))
          key = findWordInRelationShip(word, relations, index)
          relations.each do |r_key, rels|
            if key == r_key 
              return relation_key
            end
          end
        else
          if (relations == word)
            return relation_key
          end
        end
      end
    end
    return "R_NA"
  end

  def toggle(variable)
    if (variable)
      return false
    else
      return true
    end
  end

  def addKeyValue(hashVariableRef, hashVariableTarget, type, defaultValue)
    case type
    when "boolean"
      hashVariableRef.each do |key, value|
        hashVariableTarget.store(key, defaultValue)
      end
    end
  end

  def checkIfSyntaxPassed(hashVariable)
    hashVariable.each do |key, value|
      if value == false
        return false
      end 
    end
    return true 
  end

  def checkIfRelationCanBeMissing(hashVariable)
    hashVariable.each do |key, value| 
      if value == "MISSING"
        return true
      end
    end
    return false 
  end

  def insertNewRelationShip(relationShipHash, key, pair, proximity=:before)
    #relationShipHash.to_a.insert(relationShipHash.keys.index(key) + (proximity==:after ? 1 : 0), pair.first).to_h
    keys = relationShipHash.keys
    before_keys =
    case proximity
    when :before
      key==keys.first ? [[], keys] : keys.slice_before { |k| k == key }
    when :after
      keys.slice_after { |k| k == key }
    end.first
    relationShipHash.select { |k,_| before_keys.include? k }.
      update(pair).
      update(relationShipHash.reject { |k,_| before_keys.include? k })
  end  

  def solveConflicts(getRelationShips, newHasRelationShips)
    clone_getRelationShips = getRelationShips.clone
    getRelationShips.each_with_index do |(gRel, gRelValue), gIndex|
      mergedHases = newHasRelationShips.merge(clone_getRelationShips).sort.to_h
      rels = newHasRelationShips.keys.select {|k| k == gRel}
      new_gRel = gRel
      if !new_gRel.include?("THEN") and !new_gRel.include?("ELSE")
        while rels.length > 0
          if new_gRel.include?("RELATION")
            gRelNumber = new_gRel.gsub("RELATION","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "RELATION#{gRelNumber}"
          elsif new_gRel.include?("RELATIOnS")
            gRelNumber = new_gRel.gsub("RELATIOnS","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "RELATIOnS#{gRelNumber}"
          elsif new_gRel.include?("IF")
            gRelNumber = new_gRel.gsub("IF","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "IF#{gRelNumber}"
            new_gRelTHEN = "THEN#{gRelNumber}"
            new_gRelELSE = "ELSE#{gRelNumber}"
          elsif new_gRel.include?("OrLOOP")
            gRelNumber = new_gRel.gsub("OrLOOP","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "OrLOOP#{gRelNumber}"
          elsif new_gRel.include?("OR")
            gRelNumber = new_gRel.gsub("OR","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "OR#{gRelNumber}"
          elsif new_gRel.include?("BEGIN_INNER_BLOCK")
            gRelNumber = new_gRel.gsub("BEGIN_INNER_BLOCK","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "BEGIN_INNER_BLOCK#{gRelNumber}"
          elsif new_gRel.include?("END_INNER_BLOCK")
            gRelNumber = new_gRel.gsub("END_INNER_BLOCK","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "END_INNER_BLOCK#{gRelNumber}"
          elsif new_gRel.include?("BEGIN_FoR_ARGUMENT")
            gRelNumber = new_gRel.gsub("BEGIN_FoR_ARGUMENT","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "BEGIN_FoR_ARGUMENT#{gRelNumber}"
          elsif new_gRel.include?("END_FoR_ARGUMENT")
            gRelNumber = new_gRel.gsub("END_FoR_ARGUMENT","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "END_FoR_ARGUMENT#{gRelNumber}"
          elsif new_gRel.include?("END_DO_WHILE")
            gRelNumber = new_gRel.gsub("END_DO_WHILE","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "END_DO_WHILE#{gRelNumber}"
          elsif new_gRel.include?("BEGIN_ARGUMENT")
            gRelNumber = new_gRel.gsub("BEGIN_ARGUMENT","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "BEGIN_ARGUMENT#{gRelNumber}"
          elsif new_gRel.include?("END_ARGUMENT")
            gRelNumber = new_gRel.gsub("END_ARGUMENT","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "END_ARGUMENT#{gRelNumber}"
          elsif new_gRel.include?("BEGIN_CaLL_ARGUMENT")
            gRelNumber = new_gRel.gsub("BEGIN_CaLL_ARGUMENT","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "BEGIN_CaLL_ARGUMENT#{gRelNumber}"
          elsif new_gRel.include?("END_CaLL_ARGUMENT")
            gRelNumber = new_gRel.gsub("END_CaLL_ARGUMENT","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "END_CaLL_ARGUMENT#{gRelNumber}"
          elsif new_gRel.include?("BEGIN_SUBSCRIPT")
            gRelNumber = new_gRel.gsub("BEGIN_SUBSCRIPT","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "BEGIN_SUBSCRIPT#{gRelNumber}"
          elsif new_gRel.include?("END_SUBSCRIPT")
            gRelNumber = new_gRel.gsub("END_SUBSCRIPT","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "END_SUBSCRIPT#{gRelNumber}"
          elsif new_gRel.include?("BEGIN_FACTOr_EXPRESSION")
            gRelNumber = new_gRel.gsub("BEGIN_FACTOr_EXPRESSION","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "BEGIN_FACTOr_EXPRESSION#{gRelNumber}"
          elsif new_gRel.include?("END_FACTOr_EXPRESSION")
            gRelNumber = new_gRel.gsub("END_FACTOr_EXPRESSION","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "END_FACTOr_EXPRESSION#{gRelNumber}"
          elsif new_gRel.include?("BEGIN_If_ARGUMENT")
            gRelNumber = new_gRel.gsub("BEGIN_If_ARGUMENT","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "BEGIN_If_ARGUMENT#{gRelNumber}"
          elsif new_gRel.include?("END_If_ARGUMENT")
            gRelNumber = new_gRel.gsub("END_If_ARGUMENT","").to_i
            gRelNumber = gRelNumber + 1
            new_gRel = "END_If_ARGUMENT#{gRelNumber}"
          else
            new_gRel = (new_gRel.to_i + 1).to_s
          end
          rels = mergedHases.keys.select {|k| k == new_gRel}
        end
      end
      if new_gRel != gRel
        if new_gRel.include?("IF")
          gRelNumberTHEN_ELSE = gRel.gsub("IF","").to_i
          gIndexTHEN = getRelationShips.find_index {|k,_| k == "THEN#{gRelNumberTHEN_ELSE}"}
          gRelValueTHEN = clone_getRelationShips.values[gIndexTHEN]
          gIndexELSE = getRelationShips.find_index {|k,_| k == "ELSE#{gRelNumberTHEN_ELSE}"}
          gRelValueELSE = clone_getRelationShips.values[gIndexELSE]
          clone_getRelationShips = insertNewRelationShip(clone_getRelationShips, clone_getRelationShips.keys[gIndex],     Hash["#{new_gRel}",    gRelValue], :after)
          clone_getRelationShips = insertNewRelationShip(clone_getRelationShips, clone_getRelationShips.keys[gIndexTHEN], Hash["#{new_gRelTHEN}",gRelValueTHEN], :after)
          clone_getRelationShips = insertNewRelationShip(clone_getRelationShips, clone_getRelationShips.keys[gIndexELSE], Hash["#{new_gRelELSE}",gRelValueELSE], :after)
          clone_getRelationShips.delete(gRel) #IF
          clone_getRelationShips.delete("THEN#{gRelNumberTHEN_ELSE}") #THEN
          clone_getRelationShips.delete("ELSE#{gRelNumberTHEN_ELSE}") #ELSE
        elsif new_gRel.include?("OrLOOP") or new_gRel.include?("OR") or new_gRel.include?("RELATION") or new_gRel.include?("RELATIOnS") or
              new_gRel.include?("BEGIN_INNER_BLOCK") or new_gRel.include?("END_INNER_BLOCK") or 
              new_gRel.include?("BEGIN_FoR_ARGUMENT") or new_gRel.include?("END_FoR_ARGUMENT") or
              new_gRel.include?("END_DO_WHILE") or 
              new_gRel.include?("BEGIN_ARGUMENT") or new_gRel.include?("END_ARGUMENT")
              new_gRel.include?("BEGIN_CaLL_ARGUMENT") or new_gRel.include?("END_CaLL_ARGUMENT")
              new_gRel.include?("BEGIN_SUBSCRIPT") or new_gRel.include?("END_SUBSCRIPT")
              new_gRel.include?("BEGIN_FACTOr_EXPRESSION") or new_gRel.include?("END_FACTOr_EXPRESSION")              
              new_gRel.include?("BEGIN_If_ARGUMENT") or new_gRel.include?("END_If_ARGUMENT")              
              
          clone_getRelationShips = insertNewRelationShip(clone_getRelationShips, clone_getRelationShips.keys[gIndex], Hash["#{new_gRel}",gRelValue], :after)
          clone_getRelationShips.delete(gRel)
        else  
          clone_getRelationShips = insertNewRelationShip(clone_getRelationShips, clone_getRelationShips.keys[gIndex], Hash["#{new_gRel}",gRelValue], :after)
          clone_getRelationShips.delete(gRel)
        end

      end
    end
    getRelationShips = clone_getRelationShips
end

  def refineRelationShips(hasRelationShips, positionToCheckWord, word, depth)
    if hasRelationShips.empty?
      return Hash["replace",Hash["#{depth}",hasRelationShips]]      
    end
    newHasRelationShips = hasRelationShips.clone 
    orsFound = newHasRelationShips.keys.select {|k| k.include? "OR"}
    relationFound = newHasRelationShips.keys.select {|k| k.include? "RELATION"}
    relationsFound = newHasRelationShips.keys.select {|k| k.include? "RELATIOnS"}
    ifFound = newHasRelationShips.keys.select {|k| k.include? "IF"}

    if newHasRelationShips.values[positionToCheckWord] == word
      #puts("#{__LINE__} #{word} word in values[positionToCheckWord]")
      if newHasRelationShips.keys[positionToCheckWord].include?("IF")
      elsif newHasRelationShips.keys[positionToCheckWord].include?("OR")
      end
    else
#      puts("#{__LINE__} #{word} word NOT in values[positionToCheckWord]")
#      puts("#{__LINE__} newHasRelationShips: #{newHasRelationShips}")
#      puts("#{__LINE__} positionToCheckWord: #{positionToCheckWord}")
      if newHasRelationShips.keys[positionToCheckWord].include?("IF")
        ifNumber = newHasRelationShips.keys[positionToCheckWord].gsub("IF","")
        findWordInIF = newHasRelationShips[newHasRelationShips.keys[positionToCheckWord]].values.find {|v| v.include? "#{word}"}
        findWordInELSE = newHasRelationShips["ELSE#{ifNumber}"].values.find {|v| v.include? "#{word}"}
        a = newHasRelationShips[newHasRelationShips.keys[positionToCheckWord]]
        if findWordInIF.nil? and findWordInELSE.nil?
          # search again
          if !newHasRelationShips[newHasRelationShips.keys[positionToCheckWord]].keys.find {|v| v.include? ("RELATIO" or "OR")}.nil?
            getRelationShips = refineRelationShips(newHasRelationShips[newHasRelationShips.keys[positionToCheckWord]], 0, word, depth + 1)
            shouldReplace = getRelationShips.keys.select { |k,v| k.include? "replace"}
            shouldAdd  = getRelationShips.keys.select { |k,v| k.include? "add"}
            if shouldReplace.length > 0
              if getRelationShips.is_a?(Hash)
                newHasRelationShips = insertNewRelationShip(newHasRelationShips, "IF#{ifNumber}", Hash["IF#{ifNumber}",getRelationShips["replace"].values[0]], :after)
              end
            end
            findWordInIF = newHasRelationShips[newHasRelationShips.keys[positionToCheckWord]].values.find { |v| v.include? "#{word}" }
          end
        end

        if !findWordInIF.nil?  # THEN+number

          getRelationShips = newHasRelationShips["IF#{ifNumber}"]

          if getRelationShips.is_a?(Hash)
            getRelationShips = solveConflicts(getRelationShips, newHasRelationShips)
          end
  
          newHasRelationShips = insertNewRelationShip(newHasRelationShips, "IF#{ifNumber}", getRelationShips, :after)
          findWord = hasRelationShips["THEN#{ifNumber}"].values.find {|k| k.include? "#{word}"}

          getRelationShips = hasRelationShips["THEN#{ifNumber}"]
          if getRelationShips.is_a?(Hash)
            getRelationShips = solveConflicts(getRelationShips, newHasRelationShips)
          end
  
          newHasRelationShips = insertNewRelationShip(newHasRelationShips, "THEN#{ifNumber}", getRelationShips, :after)
          newHasRelationShips.delete("IF#{ifNumber}")
          newHasRelationShips.delete("THEN#{ifNumber}")
          newHasRelationShips.delete("ELSE#{ifNumber}")
        else               # ELSE+number

          getRelationShips = hasRelationShips["ELSE#{ifNumber}"]
          if getRelationShips.is_a?(Hash) and !getRelationShips.empty?
            getRelationShips = solveConflicts(getRelationShips, newHasRelationShips)
          else
            currentIndex = hasRelationShips.find_index {|k,_| k == "ELSE#{ifNumber}"}
            getNextIndexKey = currentIndex + 1
            getNextKey = hasRelationShips.keys[getNextIndexKey]
          end
  
          newHasRelationShips = insertNewRelationShip(newHasRelationShips, "ELSE#{ifNumber}", getRelationShips, :after)
          findWord = hasRelationShips["ELSE#{ifNumber}"].values.find {|k| k.include? "#{word}"}
          newHasRelationShips.delete("IF#{ifNumber}")
          newHasRelationShips.delete("THEN#{ifNumber}")
          newHasRelationShips.delete("ELSE#{ifNumber}")
          if getRelationShips.empty?# and !getNextKey.include?("IF")
            getRelationShips = refineRelationShips(newHasRelationShips, positionToCheckWord, word, depth + 1)
            shouldReplace = getRelationShips.keys.select { |k,v| k.include? "replace"}
            shouldAdd  = getRelationShips.keys.select { |k,v| k.include? "add"}
            if shouldReplace.length > 0
              if getRelationShips.is_a?(Hash)
                newHasRelationShips = getRelationShips["replace"].values[0].clone
              end
            end
          elsif findWord.nil?
            getRelationShips = refineRelationShips(newHasRelationShips, positionToCheckWord, word, depth + 1)
            shouldReplace = getRelationShips.keys.select { |k,v| k.include? "replace"}
            shouldAdd  = getRelationShips.keys.select { |k,v| k.include? "add"}
            if shouldReplace.length > 0
              if getRelationShips.is_a?(Hash)
                newHasRelationShips = getRelationShips["replace"].values[0].clone
              end
            end
          end
        end
        return Hash["replace",Hash["#{depth}",newHasRelationShips]]
 
      elsif newHasRelationShips.keys[positionToCheckWord].include?("OR")
        #puts("#{__LINE__} newHasRelationShips: #{newHasRelationShips}")
        keyToDelete = newHasRelationShips.keys[positionToCheckWord]
        newHasRelationShips.values[positionToCheckWord].values.find { |v| v.include? "#{word}"}
        wordInOR = newHasRelationShips.values[positionToCheckWord].select { |k,v| v.include? "#{word}"}
        if !wordInOR.empty?
          wordInOR = solveConflicts(wordInOR, newHasRelationShips)
          newHasRelationShips = insertNewRelationShip(newHasRelationShips, newHasRelationShips.keys[positionToCheckWord], wordInOR, :after)
          newHasRelationShips.delete(newHasRelationShips.keys[positionToCheckWord])
          return Hash["replace",Hash["#{depth}",newHasRelationShips]]

        else
#          newHasRelationShips_ = newHasRelationShips.clone
#          relationShip = newHasRelationShips_.values[positionToCheckWord] 
          newHasRelationShips_ = newHasRelationShips.values[positionToCheckWord].clone
          relationShip = newHasRelationShips_.clone
          relShip = Hash.new
          rels = relationShip.keys.select { |k,v| k.include? "RELATIO"}
          rels.each_with_index do |rel, index|
            relationShip_ = refineRelationShips(Hash[rel,relationShip[rel]], 0, word, depth + 1)
            shouldReplace = relationShip_.keys.select { |k,v| k.include? "replace"}
            shouldAdd  = relationShip_.keys.select { |k,v| k.include? "add"}
            wordInRelation = relationShip_["replace"].values[0].values[0]
            if word == relationShip_["replace"].values[0].values[0]
              if shouldReplace.length > 0
                #puts("#{__LINE__} #{relationShip_}")
                if relationShip_.is_a?(Hash)
                  relationShip_ = solveConflicts(relationShip_["replace"].values[0], relationShip)
                end
                newHasRelationShips_ = insertNewRelationShip(newHasRelationShips_, relationShip.keys[index], relationShip_, :after)
                newHasRelationShips_.delete(relationShip.keys[index])
              end

            else
              newHasRelationShips_.delete(relationShip.keys[index])
            end
          end
          newHasRelationShips_ = solveConflicts(newHasRelationShips_, newHasRelationShips)
          newHasRelationShips = insertNewRelationShip(newHasRelationShips, keyToDelete, newHasRelationShips_, :after)
          newHasRelationShips.delete(newHasRelationShips.keys[positionToCheckWord])
          return Hash["replace",Hash["#{depth}",newHasRelationShips]]

        end                                                                        

      elsif newHasRelationShips.keys[positionToCheckWord].include?("OrLOOP")
        #puts("#{__LINE__} newHasRelationShips: #{newHasRelationShips}")
        keyToDelete = newHasRelationShips.keys[positionToCheckWord]
        newHasRelationShips.values[positionToCheckWord].values.find { |v| v.include? "#{word}"}
        wordInOR = newHasRelationShips.values[positionToCheckWord].select { |k,v| v.include? "#{word}"}
        if !wordInOR.empty?
          if wordInOR.is_a?(Hash)
            wordInOR = solveConflicts(wordInOR, newHasRelationShips)
          end
          newHasRelationShips = insertNewRelationShip(newHasRelationShips, newHasRelationShips.keys[positionToCheckWord], wordInOR, :after)
          newHasRelationShips.delete(newHasRelationShips.keys[positionToCheckWord])
          return Hash["replace",Hash["#{depth}",newHasRelationShips]]
        else
          newHasRelationShips_ = newHasRelationShips.values[positionToCheckWord].clone
          relationShip = newHasRelationShips_.clone
          relShip = Hash.new
#          rels = relationShip.keys.select { |k,v| k.include? "RELATIO"}
          rels = relationShip.keys.select { |k,v| k}
          rels.each_with_index do |rel, index|
            relationShip_ = refineRelationShips(Hash[rel,relationShip[rel]], 0, word, depth + 1)
            shouldReplace = relationShip_.keys.select { |k,v| k.include? "replace"}
            shouldAdd  = relationShip_.keys.select { |k,v| k.include? "add"}
            wordInRelation = relationShip_["replace"].values[0].values[0]
            if word == relationShip_["replace"].values[0].values[0]
              if shouldReplace.length > 0
#                puts("#{__LINE__} #{relationShip_}")
                if relationShip_.is_a?(Hash)
                  relationShip_ = solveConflicts(relationShip_["replace"].values[0], relationShip)
                end
                newHasRelationShips_ = insertNewRelationShip(newHasRelationShips_, relationShip.keys[index], relationShip_, :after)
                newHasRelationShips_.delete(relationShip.keys[index])
              end

            else
              newHasRelationShips_.delete(relationShip.keys[index])
            end
          end
          newHasRelationShips_ = solveConflicts(newHasRelationShips_, newHasRelationShips)
          newHasRelationShips = insertNewRelationShip(newHasRelationShips, keyToDelete, newHasRelationShips_, :before)
#          newHasRelationShips.delete(newHasRelationShips.keys[positionToCheckWord])
          return Hash["replace",Hash["#{depth}",newHasRelationShips]]

        end                                                                        

      elsif newHasRelationShips.keys[positionToCheckWord].include?("RELATION")
        relationShip = newHasRelationShips.values[positionToCheckWord]
        getRelationShips = @syntax.getRelationships(relationShip)
        getRelationShips_ = {}
        n = 0 
        wordInOR = getRelationShips.select { |k,v| v.include? "#{word}"}
        while wordInOR.empty? and n < 1000 and getRelationShips_ != getRelationShips
          getRelationShips_ = getRelationShips
          getRelationShips = refineRelationShips(getRelationShips, 0, word, depth + 1)
          shouldReplace = getRelationShips.keys.select { |k,v| k.include? "replace"}
          shouldAdd  = getRelationShips.keys.select { |k,v| k.include? "add"}
          if shouldReplace.length > 0
            if getRelationShips.is_a?(Hash)
              getRelationShips = getRelationShips["replace"].values[0].clone
            end
          end
          wordInOR = getRelationShips.select { |k,v| v.include? "#{word}"}
          n = n + 1
        end
        if !wordInOR.empty?
          # get all keys from newHasRelationShip and if found in gerRelationShips increment them
          if getRelationShips.is_a?(Hash)
            getRelationShips = solveConflicts(getRelationShips, newHasRelationShips)
          end
          newHasRelationShips = insertNewRelationShip(newHasRelationShips, newHasRelationShips.keys[positionToCheckWord], getRelationShips, :after)
          newHasRelationShips.delete(newHasRelationShips.keys[positionToCheckWord])
          return Hash["replace",Hash["#{depth}",newHasRelationShips]]
        else
#            clone_getRelationShips = getRelationShips.clone
#            relationShip_ = refineRelationShips(getRelationShips, 0, word, depth + 1)
#            shouldReplace = relationShip_.keys.select { |k,v| k.include? "replace"}
#            shouldAdd  = relationShip_.keys.select { |k,v| k.include? "add"}
#            if shouldReplace.length > 0
#              clone_getRelationShips = insertNewRelationShip(clone_getRelationShips, clone_getRelationShips.keys[0], relationShip_["replace"].values[0], :after)
#              if getRelationShips != clone_getRelationShips
#                clone_getRelationShips.delete(clone_getRelationShips.keys[0])
#              end
#            end
#            getRelationShips = clone_getRelationShips
            if getRelationShips.is_a?(Hash)
              getRelationShips = solveConflicts(getRelationShips, newHasRelationShips)
            end
            newHasRelationShips = insertNewRelationShip(newHasRelationShips, newHasRelationShips.keys[positionToCheckWord], getRelationShips, :after)
            newHasRelationShips.delete(newHasRelationShips.keys[positionToCheckWord])
            return Hash["replace",Hash["#{depth}",newHasRelationShips]]
        end
      
      elsif newHasRelationShips.keys[positionToCheckWord].include?("RELATIOnS")
        relationShips = newHasRelationShips.values[positionToCheckWord]
        newHasRelationShips_ = Hash.new
        n = 0
        relationShips.split(" ").each_with_index do |relationShip, index|
          getRelationShips = @syntax.getRelationships(relationShip)
          
          if getRelationShips != "R_NA"
            wordInOR = getRelationShips.select { |k,v| v.include? "#{word}"}
            if !wordInOR.empty?
              if getRelationShips.is_a?(Hash)
                getRelationShips = solveConflicts(getRelationShips, newHasRelationShips_)
              end
            else #dig more inside
#              clone_getRelationShips = getRelationShips.clone
#              relationShip_ = refineRelationShips(getRelationShips, 0, word, depth + 1)
#              shouldReplace = relationShip_.keys.select { |k,v| k.include? "replace"}
#              if shouldReplace.length > 0
#                clone_getRelationShips = insertNewRelationShip(clone_getRelationShips, clone_getRelationShips.keys[0], relationShip_["replace"].values[0], :after)
#                clone_getRelationShips.delete(clone_getRelationShips.keys[0])
#              end
#              getRelationShips = clone_getRelationShips
              if getRelationShips.is_a?(Hash)
                getRelationShips = solveConflicts(getRelationShips, newHasRelationShips_)
              end
            end
          else
            getRelationShips = {}
            getRelationShips.merge(Hash["#{n}","#{relationShip}"])
            if getRelationShips.is_a?(Hash)
              getRelationShips = solveConflicts(getRelationShips, newHasRelationShips_)
            end
          end
          newHasRelationShips_.merge!(getRelationShips)
          n = n + 1
        end
        newHasRelationShips = insertNewRelationShip(newHasRelationShips, newHasRelationShips.keys[positionToCheckWord], newHasRelationShips_, :after)
        newHasRelationShips.delete(newHasRelationShips.keys[positionToCheckWord])
        return Hash["replace",Hash["#{depth}",newHasRelationShips]]            

      end
    end
    return Hash["replace",Hash["#{depth}",hasRelationShips]]

  end

  def displayError(syntaxError)
    case syntaxError[:errorType]
    when "SYNTAX_ERROR"
      fileContent = File.readlines(@fileName)
      line = fileContent[syntaxError[:lineNumber]-1]
      puts "line number: #{syntaxError[:lineNumber]}"
      puts "#{line}"
      wordPosition = line.index(line.split(" ")[syntaxError[:wordNumber]-1]);
      (0..(wordPosition.to_i-1)).each do 
          putc "-"
      end
      putc "^"
    end
  end

  def syntaxChecker(file)
    @fileName = file
    @tempFileContent = "#{file}.translated"
    syntaxError = checkSyntax()
    if !syntaxError.nil?
      displayError(syntaxError)
    end
  end

  def checkSyntax()
    puts "Script syntax checker Started"
    typeOfKeyword = "K_NA"  #Keyword notAvailable  
    typeOfOperand = "O_NA"  #Operand notAvailable  
    typeOfRelation = "R_NA" #Relationship notAvailable  

    nextIdentifier = false
    nextString = false
    nextCompound2BeFound = false
    nextWord = ""
    includeFiles = Hash.new
    includeFilesIndex = -1
    functionDefinitions = Hash.new
    functionDefinitionsIndex = -1
    variables = Hash.new
    variableIndex = -1
    syntaxLevelFlow = Hash.new 
    syntaxLevelFlowIndex = -1
    syntaxRelations = Hash.new
    syntaxRelationsIndex = 0
    syntaxRelationsIndexStack = Array.new
    syntaxRelationsTAGsStack = Array.new
    checkingSyntaxRelations = false
    syntaxforbidenRelations = Hash.new
    syntaxRelationsOR = Hash.new
    forbidenRelations = Hash.new
    syntaxOK = true
    isError = "true"
    isActivated = {                          
                    "T_INCLUDE" => false,
                    "T_VAR"     => false,
                    "T_DEF"     => false,
                    "T_FOR"     => false,
                    "T_FOREACH" => false,
                    "T_IF"      => false,
                    "T_ELSE"    => false,
                    "T_ELSEIF"  => false,
                    "T_DO"      => false,
                    "T_PUTS"    => false,
                    "T_RETURN"  => false
                  }                            

    #puts tempFileContent
    fileContent = File.open(@tempFileContent).read        #open file tempFileContent for each which is a translation of the source
    fileContent.gsub!(/\r\n?/,"\n")                      #replace all \r\n with \n only 
    word = ""
    aux_word = ""
    lastWord = ""
    syntaxWordIndex = 0
    hasRelationsShips = "R_NA"
    fileContent.each_line.with_index do |line, lineNumber|  #for each line do the block below
      #puts("#{__LINE__} #{lineNumber} LINE: #{line}")
      wordsFromLine = line.split(" ")                       #split line in chars
      word = ""
      aux_word = ""
      word_idx = 0
      isCompound = false
      isActivated = {
                      "T_INCLUDE" => false,
                      "T_DEF"     => false,
                      "T_FOR"     => false,
                      "T_FOREACH" => false,
                      "T_IF"      => false,
                      "T_ELSE"    => false,
                      "T_ELSEIF"  => false,
                      "T_DO"      => false,
                      "T_PUTS"    => false,
                      "T_RETURN"  => false
                    }
      
      compoundString = ""
      isTypeOfConst = {
                        "type" => "",
                        "value" => false
                      }
      hasRelationShips = nil

      while ( word_idx < wordsFromLine.length ) do          #parce each char until end of line
        word = wordsFromLine[word_idx]
#        puts("#{__LINE__} #{lineNumber} LINE: #{line}")        
#        puts("#{__LINE__} word: #{word} syntaxWordIndex: #{syntaxWordIndex}")

        if lineNumber == 11 and syntaxWordIndex == 11
          puts "line = #{lineNumber} | syntaxWordIndex = #{syntaxWordIndex}"
        end
          hasRelationShips = @syntax.getRelationships(word)
        if !aux_word.empty?
          aux_word = ""
        else 
          if (hasRelationShips != "R_NA")                     #syntaxLevelFlow store and increment index

            #should be indexed and stored in the apropriate structures... TBC
            case word
            when "T_VAR"
              variableIndex = variableIndex + 1

            when "T_INCLUDE"
              includeFilesIndex = includeFilesIndex + 1

            when "T_DEF"
              functionDefinitionsIndex = functionDefinitionsIndex + 1

            end
            if (syntaxLevelFlowIndex > -1)
              syntaxRelationsIndexStack.insert(syntaxLevelFlowIndex, syntaxWordIndex)
              syntaxWordIndex = 0
            end 

            syntaxLevelFlowIndex = syntaxLevelFlowIndex + 1
            syntaxLevelFlow.store(syntaxLevelFlowIndex, hasRelationShips)

          else #(hasRelationsShips != "R_NA")                #use syntaxLevelFlow relations

            # refine relationship based on the if structure or relation
            syntaxLevelFlowBack = syntaxLevelFlow[syntaxLevelFlowIndex].clone

            # refine begin
            #puts("#{__LINE__} LINE: #{line}")            
            #puts("#{__LINE__} lineNumber: #{lineNumber} | word: #{word} ")
            #puts("#{__LINE__} word_idx: #{word_idx} syntaxWordIndex: #{syntaxWordIndex}")              
            #puts("#{__LINE__} syntaxLevelFlow[#{syntaxLevelFlowIndex}].keys[#{syntaxWordIndex}]: #{syntaxLevelFlow[syntaxLevelFlowIndex].keys[syntaxWordIndex]} ")
            #puts("#{__LINE__} syntaxLevelFlow[#{syntaxLevelFlowIndex}].values[#{syntaxWordIndex}]: #{syntaxLevelFlow[syntaxLevelFlowIndex].values[syntaxWordIndex]}")
            newSyntaxLevelFlowRefined = refineRelationShips(syntaxLevelFlow[syntaxLevelFlowIndex], syntaxWordIndex, word, 0)
            shouldReplace = newSyntaxLevelFlowRefined.keys.select { |k,v| k.include? "replace"}
            shouldAdd  = newSyntaxLevelFlowRefined.keys.select { |k,v| k.include? "add"}
            if shouldReplace.length > 0
              syntaxLevelFlow.delete(syntaxLevelFlowIndex)
              syntaxLevelFlow.store(syntaxLevelFlowIndex, newSyntaxLevelFlowRefined["replace"].values[0]) #refineRelationShips(syntaxLevelFlow[syntaxLevelFlowIndex], word) 
            end

            if shouldAdd.length > 0
              if (syntaxLevelFlowIndex > -1)
                syntaxRelationsIndexStack.insert(syntaxLevelFlowIndex, syntaxWordIndex)
                syntaxWordIndex = 0
              end 
              syntaxLevelFlowIndex = syntaxLevelFlowIndex + 1
              syntaxLevelFlow.store(syntaxLevelFlowIndex, hasRelationShips)
              syntaxWordIndex = 0
            end
            # refine ended
            #puts("#{__LINE__} refined syntaxLevelFlow: #{syntaxLevelFlow.inspect}")
           
            #puts ("#{__LINE__} findWordInRelationShip: #{findWordInRelationShip(word, syntaxLevelFlow[syntaxLevelFlowIndex],syntaxWordIndex)}")
            subRelationShip = syntaxLevelFlow[syntaxLevelFlowIndex].keys[syntaxWordIndex]
            #puts("#{__LINE__} subRelationShip: #{subRelationShip}")
            #subRelationShip = findWordInRelationShip(word, syntaxLevelFlow[syntaxLevelFlowIndex],"|---")

            if subRelationShip != "R_NA"
              if !syntaxLevelFlow[syntaxLevelFlowIndex].values[syntaxWordIndex].is_a?(Hash)
                if syntaxLevelFlow[syntaxLevelFlowIndex].values[syntaxWordIndex] != word
                  return {:errorType => "SYNTAX_ERROR", :lineNumber => lineNumber+1, :wordNumber => word_idx, :line => line}
                end
              else
                #in this case will be parsed according to subRelationShip
              end

              case subRelationShip 
              when "END_STATEMENT", "END_BLOCK"
                isTypeOfConst["type"] = ""
                isTypeOfConst["value"] = false
                case word 
                when "O_END_OF_STATEMENT"  
                when "O_BLOCK_CLOSE"
                end
                
                syntaxLevelFlow.delete(syntaxLevelFlow.keys[syntaxLevelFlowIndex])
                syntaxLevelFlowIndex = syntaxLevelFlowIndex - 1
                if syntaxLevelFlowIndex > -1 
                  syntaxWordIndex = syntaxRelationsIndexStack.pop
                  syntaxWordIndex = syntaxWordIndex - 1
                else 
                  syntaxWordIndex = -1 
                end

              when /OR/,/Or/ 
                case word
                when "N_VALUE"
                  #puts ("#{__LINE__} N_VALUE")                  
                  aux_word = word
                when "I_VALUE"
                  #puts ("#{__LINE__} I_VALUE")
                  aux_word = word
                when "S_VALUE"
                  #puts ("#{__LINE__} S_VALUE")                  
                  aux_word = word
                when "O_OPEN_CLOSE_COMPOUND"
                  isCompound = toggle(isCompound)
                  if (!isCompound)
                    if (isTypeOfConst["value"])
                    end
                  end
                end

#                aux_word = word

              when "0".."9", "10".."99", "100".."999"
                case word
                when "N_VALUE"
                  aux_word = word
                when "I_VALUE"
                  aux_word = word
                when "S_VALUE"
                  aux_word = word
                when "O_OPEN_CLOSE_COMPOUND"
                  isCompound = toggle(isCompound)
                  if (!isCompound)
                    if (isTypeOfConst["value"])
                    end
                  end
                end
              end
#              puts("#{__LINE__} word: #{word}")
              syntaxWordIndex = syntaxWordIndex + 1
            else 
              #identifiers and strings should be stored in the apropriate structures TBC
              if (isTypeOfConst["value"] and !isCompound)
              end
              if (isTypeOfConst["value"] and isCompound)
                if (!@syntax.isTypeOfConst?(word))
                  if (compoundString == "")
                    compoundString = word
                  else
                    compoundString = compoundString + " " + word
                  end
                end
              end  
            end

          end #(hasRelationsShips != "R_NA")
        end
        word_idx = word_idx + 1
      end
    end
    puts "Script syntax checker Done"    
  end
end #class SyntaxChecker

end #module RubyScript2CAPLConverter
