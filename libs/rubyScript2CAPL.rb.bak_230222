require_relative 'rubyScript2CAPL/version.rb'
require_relative 'rubyScript2CAPL/syntax.rb'

module RubyScript2CAPL

class Converter
  attr_accessor :keywords, :error, :errorList, :specialChar
  attr_accessor :includeFiles, :functionNames, :variableNames

  def initialize()
    puts "Script2CAPLConverter"
    puts "Version: #{VERSIONCONVERTER}"
    @keywords = Syntax.new()
    @includeFiles = Array.new
    @functionNames = Hash.new # {"functionName" => {0 => "param1", 1 => "param2"}
    @variableNames = Array.new
    @error = Hash.new #{ "Error Name" => {0 => "Linenumber",     1 => "whatkindoferror",       2 => "awaiting values are"               }
                      #    generated         codeGenerated      key@errorList=>0 or 1       generated based on relations
    @errorList = {0 => "not a relationship", 1 => "forbidenRelation" }
    @specialChar = [
                      "(", 
                      ")",
                      "[",
                      "]",
                      "{",
                      "}",
                      ";",
                      ":",
                      ",",
                      #".",
                      "\"",
                      "'",
                      "_",
                      "-",
                      "+",
                      "=",
                      "?",
                      " ",
                      "#",
                      "|",
                      "<",
                      ">",
                      "\/",
                      "\\",
                      "~",
                      "!",
                      "@",
                      "$",
                      "%",
                      "^",
                      "&",
                      "*",
                      "\n",
                      "\t",
                      "\r"
                   ]
  end
    
  def convert(file2Convert)
    parseAndTranslateToSyntaxSimbols(file2Convert)
  end
    
  def parseAndTranslateToSyntaxSimbols(file2Convert)
    typeOfToken = "K_NA" #Keyword notAvailable  
    typeOfOperand = "O_NA" #Operand notAvailable  
    typeOfRelation = "R_NA" #Relationship notAvailable  
    
    openCloseCompound = 0;
    openCloseBraket = 0;
    openCloseParant = 0;
    openCloseBraces = 0;
    compoundVariable = Array.new
          
    fileContent = File.open(file2Convert).read
    tempFileContent = File.open("tempFileContent.translated","w")
    
    fileContent.gsub!(/\r\n?/,"\n")
      
    fileContent.each_line do |line|
      charsFromLine = line.split("")
        
      word = ""
      wordLast = ""
      specialWord = ""
      specialWordLast = "" 
      haveWord = false
      haveWordOldState = haveWord
      gotoNextLine = false
      currentToken = "T_NA"
      isCompound = false
      isParanthesis = false
      isBraket = false
      isBraces = false
        
      charsFromLine.each_with_index.map do |chr, chr_idx|
        #puts "New word #{__FILE__}, #{__LINE__}"
        #puts "current CHAR: #{chr}"
        if ( gotoNextLine == false )
          if (specialChar.include?(chr))
            #puts "SPECIAL! chr -> #{chr} ORD #{chr.ord}"
            if ( chr == "#" ) 
              gotoNextLine = true
              next
            end

            case chr
            when "("
              openCloseParant = openCloseParant + 1
              #puts "Paranthesis: #{openCloseParant} word: #{word} wordLast: #{wordLast}"
            when ")"
              openCloseParant = openCloseParant - 1
              #puts "Paranthesis: #{openCloseParant} word: #{word} wordLast: #{wordLast}"
              if (word.empty?)
                tempFileContent.write("EMPTY ")
              end
            when "["
              openCloseBraket = openCloseBraket + 1
              #puts "Braket: #{openCloseBraket} word: #{word} wordLast: #{wordLast}"
            when "]"
              openCloseBraket = openCloseBraket - 1
              #puts "Braket: #{openCloseBraket} word: #{word} wordLast: #{wordLast}"
            when "{"
              openCloseBraces = openCloseBraces + 1
              #puts "Braces: #{openCloseBraces} word: #{word} wordLast: #{wordLast}"
            when "}"
              openCloseBraces = openCloseBraces - 1
              #puts "Braces: #{openCloseBraces} word: #{word} wordLast: #{wordLast}"
            when "\"" 
              if (!specialWordLast.include?("\\"))
                openCloseCompound = openCloseCompound + 1
                if ( (openCloseCompound % 2) == 0 )
                  isCompound = true
                  openCloseCompound = 0
                end
              end
              #puts "\n->openCloseCompound: #{openCloseCompound}<-\n"
            end 

            if ( ( chr != "\n" ) && ( chr != "\t" ) && ( chr != "\r" ) && ( chr != " " ) )
              #puts "not \\n and not \\t and not \\r and not space!"
              specialWord = specialWord + chr
              haveWord = true
            else 
              #puts "\\n and \\t abd \\r and space!"
              if (openCloseCompound > 0)
                if ( ( chr == " " ) && ( ( openCloseCompound % 2 ) == 0 ) )
                  #puts "space! and openclosecompound:#{openCloseCompound} % 2 == 0"
                  #specialWord = specialWord + chr
                  word = word +chr
                  #haveWord = true
                elsif (chr == " ")
                  #puts "space add to word"
                  word = word +chr
                  haveWord = false
                end
              elsif ( (chr == " ") && (openCloseCompound == 0) )
                #puts "space && openCloseCompound == 0 haveWord"
                haveWord = true                  
              end
            end
            #haveWord = true
            #puts "!special! #{haveWord}"
          else #if specialChar.include?(chr) 
            #puts "notSPECIAL! chr -> #{chr} ORD #{chr.ord}"
            word = word +chr
            haveWord = false
          end #if specialChar.include?(chr)
             
          #print "#{chr}"
          if ( (haveWord == true) && (!word.empty?))
            #print "Word ->#{word}<-"
            #puts "haveWord is a Keyword #{word}"
            aux_word = word.downcase
            typeOfToken = @keywords.isToken?(aux_word)
            #puts "haveWord is a Keyword #{typeOfToken}: #{aux_word}"
            if (typeOfToken != "T_NA")
              #print typeOfKeyword, "\n"
              currentToken = typeOfToken
              tempFileContent.write("#{typeOfToken} ")
            else # if typeOfToken  != "T_NA"
              #puts "!= T_NA -> #{typeOfToken} currentToken: #{currentToken}"
              if ( currentToken != "T_NA" )
                #puts "!= T_NA openCloseCompound: #{openCloseCompound}"  
                if ( ( openCloseCompound == 0 ) && ( isCompound == true ) )
                  #puts "( openCloseCompound == 0 ) && ( isCompound == true ) S_VALUE #{aux_word} alphanumeric? ->#{@keywords.isAlphaNumeric?(aux_word)}<-"
                  tempFileContent.write("S_VALUE #{aux_word} ")
                  isCompound = false
                elsif ( ( openCloseCompound == 0 ) && ( isCompound == false ) )
                  #puts "( openCloseCompound == 0 ) && ( isCompound == false ) #{aux_word} alphanumeric? ->#{@keywords.isAlphaNumeric?(aux_word)}<-"
                  if (@keywords.isNumeric?(aux_word))
                    #puts "aux_word #{aux_word} is alphanumeric"
                    #puts "isAlphaNumeric? #{@keywords.isAlphaNumeric?(aux_word)} write to file: N_VALUE #{aux_word}"
                    tempFileContent.write("N_VALUE #{aux_word} ")
                  elsif @keywords.isAlphaNumeric?(aux_word)
                    #puts "isAlphaNumeric? #{@keywords.isAlphaNumeric?(aux_word)} write to file: I_VALUE #{aux_word}"
                    tempFileContent.write("I_VALUE #{aux_word} ")
                  end
                end
              else # if currentToken != "T_NA"
                #puts "currentToken == T_NA"
                if ( ( openCloseCompound == 0 ) && ( isCompound == true ) )
                  #puts "( openCloseCompound == 0 ) && ( isCompound == true ) S_VALUE #{aux_word} alphanumeric? ->#{@keywords.isAlphaNumeric?(aux_word)}<-"
                  tempFileContent.write("S_VALUE #{aux_word} ")
                  isCompound = false
                elsif ( ( openCloseCompound == 0 ) && ( isCompound == false ) )
                  #puts "( openCloseCompound == 0 ) && ( isCompound == false ) #{aux_word} alphanumeric? ->#{@keywords.isAlphaNumeric?(aux_word)}<-"
                  if (@keywords.isNumeric?(aux_word))
                    #puts "aux_word #{aux_word} is alphanumeric"
                    #puts "isAlphaNumeric? #{@keywords.isAlphaNumeric?(aux_word)} write to file: N_VALUE #{aux_word}"
                    tempFileContent.write("N_VALUE #{aux_word} ")
                  elsif @keywords.isAlphaNumeric?(aux_word)
                    #puts "isAlphaNumeric? #{@keywords.isAlphaNumeric?(aux_word)} write to file: I_VALUE #{aux_word}"
                    tempFileContent.write("I_VALUE #{aux_word} ")
                  end
                end
              end #if currentToken != "T_NA"
            end # if typeOfToken  != "T_NA"
            wordLast = word
            word = ""
          else #if ( (haveWord == true) && (!word.empty?))
            #print "Word ->EMPTY? ->#{word}<-\n"
            if ( !word.empty? )
              #puts "notEMPTY! W:->#{word}<- SW:->#{specialWord}<-"
              #puts "#{chr_idx} #{line.length-1}"
              if (chr_idx == line.length-1)
                #print "#{word}"
                #puts "End word is a Keyword #{word}"
                aux_word = word.downcase
                typeOfToken = @keywords.isToken?(aux_word)
                #puts "End word is a Keyword #{typeOfToken}: #{aux_word}"
                if (typeOfToken != "T_NA")
                  #print "typeOfToken != T_NA #{typeOfKeyword} \n"
                  tempFileContent.write("#{typeOfToken} ")
                else
                  #puts "!= T_NA -> #{typeOfToken} currentToken: #{currentToken}"
                  if ( currentToken != "T_NA" )
                    #puts "!= T_NA openCloseCompound: #{openCloseCompound}"
                    if (openCloseCompound == 0)
                      if (@keywords.isAlphaNumeric?(aux_word))
                        #puts "write to file: I_VALUE #{aux_word}"
                        tempFileContent.write("I_VALUE #{aux_word} ")
                      end
                    end
                  end
                end
                wordLast = word
                word = ""
              end
            end
          end#if ( (haveWord == true) && (!word.empty?))

          if ( haveWordOldState != haveWord )
            #print "|->#{specialWord}<-|"
            typeOfOperand = @keywords.isOperand?(specialWord)
            #puts "End word is a Keyword #{typeOfToken}: #{aux_word}"
            if (typeOfOperand != "O_NA")
              #print "typeOfOperand != T_NA #{typeOfOperand} \n"
              tempFileContent.write("#{typeOfOperand} ")
            end
            specialWordLast = specialWord
            specialWord = ""
            haveWordOldState = haveWord
          else #if ( haveWordOldState != haveWord )
            if ( !specialWord.empty? )
              if (chr_idx == line.length-1)
                #print "@end|->#{specialWord}<-|"
                typeOfOperand = @keywords.isOperand?(specialWord)
                #puts "End word is a Keyword #{typeOfToken}: #{aux_word}"
                if (typeOfOperand != "O_NA")
                  #print "typeOfOperand != T_NA #{typeOfOperand} \n"
                  tempFileContent.write("#{typeOfOperand} ")
                end
                specialWordLast = specialWord
                specialWord = ""
              end
            end
          end #if ( haveWordOldState != haveWord )
        end # if ( gotoNextLine == false )
      end # charsFromLine.each_with_index.map do |chr, chr_idx|
      #puts ""
      tempFileContent.write("\n")
    end
    tempFileContent.close
  end

end #class Converter

class SyntaxChecker
  attr_accessor :keywords, :error, :errorList, :specialChar
  attr_accessor :includeFiles, :functionNames, :variableNames

  def initialize()
    puts "Script2CAPLSyntaxChecker"
    puts "Version: #{VERSIONSYNTAXCHECKER}"
    @syntax = Syntax.new()
    @includeFiles = Array.new
    @functionNames = Hash.new # {"functionName" => {0 => "param1", 1 => "param2"}
    @variableNames = Array.new # {"variableName1", "variableName2", etc.}
    @error = Hash.new #{ "Error Name" => {0 => "Linenumber",     1 => "whatkindoferror",       2 => "awaiting values are"               }
                      #    generated         codeGenerated      key@errorList=>0 or 1       generated based on relations
    @errorList = {0 => "not a relationship", 1 => "forbidenRelation" }
  end

  def findWordInRelationShip(word, relationShips_, relationShipsVisited_, debug)
    puts "#{__LINE__}#{debug}/function findWordInRelationShip Begin"
    puts "#{__LINE__}#{debug}|-relationShips: #{relationShips_}"
    puts "#{__LINE__}#{debug}|-relationShipsVisited: #{relationShipsVisited_}"
    relationShips_.each do |relation_key, relations|
      puts "#{__LINE__}#{debug}|/Begin each! word: #{word} | relations: #{relations} | relation_key: #{relation_key}!"
      if (relations.is_a?(Hash))
        puts "#{__LINE__}#{debug}|-- is a Hash relations: #{relations} | word: >#{word}<"  
        key = findWordInRelationShip(word, relations, relationShipsVisited_,debug+"|-")
        puts "#{__LINE__}#{debug}|-- word: #{word} | relations: #{relations} | key: #{key}"
        relations.each do |r_key, rels|
          puts "#{__LINE__}#{debug}|---/Begin each! word: #{word} | relations: #{relations} | relation_key: #{relation_key}!"
          puts "#{__LINE__}#{debug}|--- word: #{word} | relations: #{rels} | r_key: #{r_key} | FoundKey: #{key}"
          
          if key == r_key 
            puts "#{__LINE__}#{debug}\\--- return key from each:#{relation_key}<-"
            return relation_key
          end
        end
      else
        puts "#{__LINE__}#{debug}|-- is not a Hash | relations: #{relations} | word: >#{word}<+++" 
        puts "#{__LINE__}#{debug}|-- relationShipsVisited_[#{relations}]: #{relationShipsVisited_[relation_key]}" 
        if (relations == word) and !relationShipsVisited_[relation_key]
          puts "#{__LINE__}#{debug}\\-- return key from each:#{relation_key}<-"
          return relation_key
        end
      end
      puts "#{__LINE__}#{debug}\\--- End each!"
    end
    puts "#{__LINE__}#{debug}\\- return key: R_NA<-"
    return "R_NA"
  end

  def toggle(variable)
    if (variable)
      return false
    else
      return true
    end
  end

  def addKeyValue(hashVariableRef, hashVariableTarget, type, defaultValue)
    case type
    when "boolean"
      hashVariableRef.each do |key, value|
        puts "#{__LINE__} #{key} #{value}"
        hashVariableTarget.store(key, defaultValue)
      end
    end
  end

  def checkIfSyntaxPassed(hashVariable)
    hashVariable.each do |key, value|
      if value == false
        return false
      end 
    end
    return true 
  end

  def checkIfRelationCanBeMissing(hashVariable)
    hashVariable.each do |key, value| 
      if value == "MISSING"
        return true
      end
    end
    return false 
  end

  def insertNewRelationShip(relationShipHash, key, pair, proximity=:before)
    #relationShipHash.to_a.insert(relationShipHash.keys.index(key) + (proximity==:after ? 1 : 0), pair.first).to_h
    keys = relationShipHash.keys
    before_keys =
    case proximity
    when :before
      key==keys.first ? [[], keys] : keys.slice_before { |k| k == key }
    when :after
      keys.slice_after { |k| k == key }
    end.first
    relationShipHash.select { |k,_| before_keys.include? k }.
      update(pair).
      update(relationShipHash.reject { |k,_| before_keys.include? k })
  end  

  def refineRelationShips(hasRelationShips, word, debug)
    puts "#{__LINE__}#{debug}/function refineRelationShips hasRelationShips: #{hasRelationShips.inspect} word: #{word}"
    newHasRelationShips = hasRelationShips.clone 

    orsFound = hasRelationShips.keys.select {|k| k.include? "OR"}
    puts "#{__LINE__}#{debug}|-ORs Found: #{orsFound} length: #{orsFound.length}"

    relationFound = hasRelationShips.keys.select {|k| k.include? "RELATION"}
    puts "#{__LINE__}#{debug}|-relationFound: #{relationFound} length: #{relationFound.length}"

    ifFound = hasRelationShips.keys.select {|k| k.include? "IF"}
    puts "#{__LINE__}#{debug}|-ifFound: #{ifFound} length: #{ifFound.length}"

    if ifFound.length > 0
      puts "#{__LINE__}#{debug}|-ifFound.length > 0"
      ifFound.each do |ifElement|
        ifNumber = ifElement.gsub("IF","")
        puts "#{__LINE__}#{debug}|---hasRelationShips: #{hasRelationShips.inspect}"
        puts "#{__LINE__}#{debug}|-IF found?: #{ifElement} number: #{ifNumber}"
        puts "#{__LINE__}#{debug}|--hasRelationShips[#{ifElement}] index: #{hasRelationShips.keys.index(ifElement)}"
        puts "#{__LINE__}#{debug}|--hasRelationShips[#{ifElement}]: #{hasRelationShips[ifElement]}"
        findWordInIF = hasRelationShips[ifElement].values.find {|k| k.include? "#{word}"}
        findWordInELSE = hasRelationShips["ELSE#{ifNumber}"].values.find {|k| k.include? "#{word}"}
        puts "#{__LINE__}#{debug}|--findWordInIF: #{findWordInIF}"
        puts "#{__LINE__}#{debug}|--findWordInELSE: #{findWordInELSE}"
        puts "#{__LINE__}#{debug}|---hasRelationShips: #{hasRelationShips.inspect}"
        if !findWordInIF.nil?  # THEN+number
          puts "#{__LINE__}#{debug}|---add content of IF in newHasRElationShips: #"
          newHasRelationShips = insertNewRelationShip(newHasRelationShips, "IF#{ifNumber}", hasRelationShips["IF#{ifNumber}"], :after)
          puts "#{__LINE__}#{debug}|---newHasRelationsShips: #{newHasRelationShips.inspect}"
          findWord = hasRelationShips["THEN#{ifNumber}"].values.find {|k| k.include? "#{word}"}
          puts "#{__LINE__}#{debug}|---then findWordInIF: #{findWordInIF}"
          puts "#{__LINE__}#{debug}|---add content of THEN in newHasRElationShips: #"
          newHasRelationShips = insertNewRelationShip(newHasRelationShips, "THEN#{ifNumber}", hasRelationShips["THEN#{ifNumber}"], :after)
          puts "#{__LINE__}#{debug}|---newHasRelationsShips: #{newHasRelationShips.inspect}"
          puts "#{__LINE__}#{debug}|---hasRelationShips: #{hasRelationShips.inspect}"
          newHasRelationShips.delete("IF#{ifNumber}")
          newHasRelationShips.delete("THEN#{ifNumber}")
          newHasRelationShips.delete("ELSE#{ifNumber}")
        else               # ELSE+number
          puts "#{__LINE__}#{debug}|-IF found?: #{ifElement} number: #{ifNumber}"
          newHasRelationShips = insertNewRelationShip(newHasRelationShips, "ELSE#{ifNumber}", hasRelationShips["ELSE#{ifNumber}"], :after)
          findWord = hasRelationShips["ELSE#{ifNumber}"].values.find {|k| k.include? "#{word}"}
          puts "#{__LINE__}#{debug}|---else findWordInELSE: #{findWordInELSE}"
          puts "#{__LINE__}#{debug}|---newHasRelationsShips: #{newHasRelationShips.inspect}"
          puts "#{__LINE__}#{debug}|---hasRelationShips: #{hasRelationShips.inspect}"
          newHasRelationShips.delete("IF#{ifNumber}")
          newHasRelationShips.delete("THEN#{ifNumber}")
          newHasRelationShips.delete("ELSE#{ifNumber}")
        end
#        if !findWordInIF.nil? or !findWordInELSE.nil?
#          addRelations = false
#          puts "#{__LINE__}#{debug}|---AddRelations false hasRelationShips: #{hasRelationShips.inspect}"
#          hasRelationShips.each do |key, value|
#            puts "#{__LINE__}#{debug}|---foreach hasRelationShips: #{hasRelationShips.inspect}"
#            if addRelations
#              newHasRelationShips.store(key,value)
#            end
#            if key == "ELSE#{ifNumber}"
#              addRelations = true
#            end
#          end
#        end
        puts "#{__LINE__}#{debug}|---returning newHasRelationsShips: #{newHasRelationShips.inspect}"
        puts "#{__LINE__}#{debug}|---hasRelationShips: #{hasRelationShips.inspect}"
        puts "#{__LINE__}#{debug}\\function refineRelationShips hasRelationShips: #{hasRelationShips.inspect} word: #{word}"
        return newHasRelationShips
      end
    end 
    
    if relationFound.length > 0
      puts "#{__LINE__}#{debug}|-relationFound.length > 0"
      relationFound.each do |relationElement|
        puts "#{__LINE__}#{debug}|-hasRelationShips[#{relationElement}]: #{hasRelationShips[relationElement]} "
        relationShip = hasRelationShips[relationElement]
        getRelationShips = @syntax.getRelationships(relationShip)
        newHasRelationShips = insertNewRelationShip(newHasRelationShips, relationElement, getRelationShips, :after)
        newHasRelationShips.delete(relationElement)
        puts "#{__LINE__}#{debug}|-getRelationShips: #{getRelationShips.inspect}"
      end
      puts "#{__LINE__}#{debug}|---returning newHasRelationsShips: #{newHasRelationShips.inspect}"
      puts "#{__LINE__}#{debug}\\function refineRelationShips hasRelationShips: #{hasRelationShips.inspect} word: #{word}"
      return newHasRelationShips
    end

    if orsFound.length > 0
      puts "#{__LINE__}#{debug}|-orsFound.length > 0"
      orsFound.each do |orElement|
        puts "#{__LINE__}#{debug}|-hasRelationShips[#{orElement}]: #{hasRelationShips[orElement]} "
        wordFoundInValue = hasRelationShips[orElement].select {|k,v| v.include?(word)}
        if wordFoundInValue.is_a(Hash)
        end 
        puts "#{__LINE__}#{debug}|-values: #{values} "
        hasRelationShips[orElement].each do |key, value|
          puts "#{__LINE__}#{debug}|-hasRelationShips[#{orElement}]: #{hasRelationShips[orElement]} "
        end
        relationFound = hasRelationShips.keys.select {|k| k.include? "RELATION"}
        puts "#{__LINE__}#{debug}|-relationFound: #{relationFound} length: #{relationFound.length}"
      end

    end
    puts "#{__LINE__}#{debug}|---returning hasRelationsShips: #{hasRelationShips.inspect}"
    puts "#{__LINE__}#{debug}\\function refineRelationShips hasRelationShips: #{hasRelationShips.inspect} word: #{word}"
    return hasRelationShips 

  end

  def checkSyntanx(tempFileContent)
    typeOfKeyword = "K_NA"  #Keyword notAvailable  
    typeOfOperand = "O_NA"  #Operand notAvailable  
    typeOfRelation = "R_NA" #Relationship notAvailable  

    nextIdentifier = false
    nextString = false
    nextCompound2BeFound = false
    nextWord = ""
    includeFiles = Hash.new
    includeFilesIndex = -1
    functionDefinitions = Hash.new
    functionDefinitionsIndex = -1
    syntaxLevelFlow = Hash.new 
    syntaxLevelFlowVisited = Hash.new 
    syntaxLevelFlowIndex = -1
    syntaxRelations = Hash.new
    syntaxRelationsIndex = 0
    syntaxRelationsIndexStack = Array.new
    checkingSyntaxRelations = false
    syntaxforbidenRelations = Hash.new
    syntaxRelationsOR = Hash.new
    forbidenRelations = Hash.new
    syntaxOK = true
    isError = "true"
    isActivated = {                          
                    "T_INCLUDE" => false,
                    "T_DEF"     => false,
                    "T_FOR"     => false,
                    "T_FOREACH" => false,
                    "T_IF"      => false,
                    "T_ELSE"    => false,
                    "T_ELSEIF"  => false,
                    "T_DO"      => false,
                    "T_PUTS"    => false,
                    "T_RETURN"  => false
                  }                            

    #puts tempFileContent
    fileContent = File.open(tempFileContent).read        #open file tempFileContent for each which is a translation of the source
    fileContent.gsub!(/\r\n?/,"\n")                      #replace all \r\n with \n only 
    word = ""
    aux_word = ""
    lastWord = ""
    syntaxWordIndex = 0
    hasRelationsShips = "R_NA"
    puts "#{__LINE__} fileContent.each_line Begin -------"
    fileContent.each_line.with_index do |line, lineNumber|  #for each line do the block below
      puts "\n#{__LINE__}/fileContent.each_line Inside Begin LineNumber:#{lineNumber}---------------------------------------------------------------------------------"
      wordsFromLine = line.split(" ")                       #split line in chars
      word = ""
      aux_word = ""
      word_idx = 0
      isCompound = false
      isActivated = {
                      "T_INCLUDE" => false,
                      "T_DEF"     => false,
                      "T_FOR"     => false,
                      "T_FOREACH" => false,
                      "T_IF"      => false,
                      "T_ELSE"    => false,
                      "T_ELSEIF"  => false,
                      "T_DO"      => false,
                      "T_PUTS"    => false,
                      "T_RETURN"  => false
                    }
      
      compoundString = ""
      isTypeOfConst = {
                        "type" => "",
                        "value" => false
                      }
                       
      puts "#{__LINE__}|-CurrentLine: #{line}"
      puts "#{__LINE__}|-#{wordsFromLine} length #{wordsFromLine.length}"
      puts "#{__LINE__}|-word_idx < wordsFromLine.length ) do Begin"
      hasRelationShips = nil

      while ( word_idx < wordsFromLine.length ) do          #parce each char until end of line
        word = wordsFromLine[word_idx]

        puts "#{__LINE__}|--NEWWORD!!!!!!!!!:>#{word}< wordsFromLine[#{word_idx}]:>#{wordsFromLine[word_idx]}< aux_word:>#{aux_word}<"
        puts "#{__LINE__}|--hasRelationShips: #{hasRelationShips}"
        hasRelationShips = @syntax.getRelationships(word)

        puts "#{__LINE__}|--hasRelationShips: #{hasRelationShips}"
        if (hasRelationShips != "R_NA")                     #syntaxLevelFlow store and increment index
          puts "#{__LINE__}|---hasRelationShips != \"R_NA\" word: #{word}"
          case word
          when "T_INCLUDE"
            includeFilesIndex = includeFilesIndex + 1

          when "T_DEF"
            functionDefinitionsIndex = functionDefinitionsIndex + 1

          end

          syntaxLevelFlowIndex = syntaxLevelFlowIndex + 1
          syntaxLevelFlow.store(syntaxLevelFlowIndex, hasRelationShips)
          syntaxLevelFlowVisited.store(syntaxLevelFlowIndex,Hash.new)
          addKeyValue(hasRelationShips, syntaxLevelFlowVisited[syntaxLevelFlowIndex], "boolean", false)

          puts "#{__LINE__}|---syntaxLevelFlowVisited: #{syntaxLevelFlowVisited.inspect}"
          puts "#{__LINE__}|---syntaxLevelFlow: #{syntaxLevelFlow.inspect}"

        else #(hasRelationsShips != "R_NA")                #use syntaxLevelFlow relations
          puts "#{__LINE__}|---hasRelationShips == \"R_NA\" word: #{word}"
          puts "#{__LINE__}|---syntaxLevelFlow: #{syntaxLevelFlow.inspect}"
          # refine relationship based on the if structure or relation

          syntaxLevelFlowBack = syntaxLevelFlow[syntaxLevelFlowIndex].clone
          puts "#{__LINE__}|---syntaxLevelFlowBack: #{syntaxLevelFlowBack}"

          # refine begin
          a = refineRelationShips(syntaxLevelFlow[syntaxLevelFlowIndex], word,"|---")
          puts "#{__LINE__}|---a: #{a}"
          
          syntaxLevelFlow.delete(syntaxLevelFlowIndex)
          syntaxLevelFlow.store(syntaxLevelFlowIndex, a) #refineRelationShips(syntaxLevelFlow[syntaxLevelFlowIndex], word,"|---") 
          # refine ended
          
          puts "#{__LINE__}|---syntaxLevelFlow[syntaxLevelFlowIndex].values[syntaxWordIndex] syntaxLevelFlow[#{syntaxLevelFlowIndex}].values[#{syntaxWordIndex}]: #{syntaxLevelFlow[syntaxLevelFlowIndex].values[syntaxWordIndex]} word: #{word}"

          puts "#{__LINE__}|---syntaxLevelFlow[#{syntaxLevelFlowIndex}]: syntaxLevelFlowBack: #{syntaxLevelFlowBack} relaced with #{syntaxLevelFlow[syntaxLevelFlowIndex]}"
          puts "#{__LINE__}|---has syntaxLevelFlow[#{syntaxLevelFlowIndex}] been changed?: syntaxLevelFlowBack == syntaxLevelFlow[syntaxLevelFlowIndex] #{syntaxLevelFlowBack == syntaxLevelFlow[syntaxLevelFlowIndex]}"
          
          if (syntaxLevelFlowBack == syntaxLevelFlow[syntaxLevelFlowIndex])
             puts "#{__LINE__}|---syntaxLevelFlow hasn't been changed"

          else
             puts "#{__LINE__}|---syntaxLevelFlow has been changed"
             syntaxLevelFlowVisitedBackup = syntaxLevelFlowVisited[syntaxLevelFlowIndex].clone
             syntaxLevelFlowVisited.delete(syntaxLevelFlowIndex)
             syntaxLevelFlowVisited.store(syntaxLevelFlowIndex,Hash.new)
             addKeyValue(syntaxLevelFlow[syntaxLevelFlowIndex], syntaxLevelFlowVisited[syntaxLevelFlowIndex], "boolean", false)
             puts "#{__LINE__}|---syntaxLevelFlowVisitedBackup check: #{syntaxLevelFlowVisitedBackup}"
             syntaxLevelFlowVisitedBackup.each do |k,v|
               puts "#{__LINE__}|---syntaxLevelFlowVisitedBackup:#{k} #{v}"
               if v == true
                 puts "#{__LINE__}|--- true update syntaxLevelFlowVisited[#{syntaxLevelFlowIndex}][#{k}]: #{syntaxLevelFlowVisited[syntaxLevelFlowIndex][k]}"
                 syntaxLevelFlowVisited[syntaxLevelFlowIndex][k] = v
               end
             end
             puts "#{__LINE__}|---syntaxLevelFlowVisited: #{syntaxLevelFlowVisited.inspect}"
              
          end

          subRelationShip = findWordInRelationShip(word, syntaxLevelFlow[syntaxLevelFlowIndex],syntaxLevelFlowVisited[syntaxLevelFlowIndex],"|---")
          puts "#{__LINE__}|---subRelationShip: #{subRelationShip}!!!!!!!!!!!!!!!!!!!!!"

          case subRelationShip
          when /OR/ 
            puts "#{__LINE__}|----OR subrelationShip"
            puts "#{__LINE__}|---- decrementing syntaxLevelFlowIndex: #{syntaxLevelFlowIndex}"
            isConst = @syntax.isTypeOfConst?(word)
            if (isConst)
              isTypeOfConst["type"] = word
              isTypeOfConst["value"] = isConst 
            end

            case word
            when "I_VALUE"
              puts "#{__LINE__}|----isTypeOfConst?(#{word}): #{isTypeOfConst["type"]}, #{isTypeOfConst["value"]}"


            when "S_VALUE"
              puts "#{__LINE__}|----isTypeOfConst?(#{word}): #{isTypeOfConst["type"]}, #{isTypeOfConst["value"]}"
            
#            when ""
            when "O_OPEN_CLOSE_COMPOUND"
              isCompound = toggle(isCompound)
              if (!isCompound)
                puts "#{__LINE__}|----COMPOUND word:>#{compoundString}<"
                if (isTypeOfConst["value"])
                  puts "#{__LINE__}|-----#{compoundString} is #{isTypeOfConst["type"]}" 
                end
              else 
                syntaxLevelFlowVisited[syntaxLevelFlowIndex][subRelationShip] = toggle(syntaxLevelFlowVisited[syntaxLevelFlowIndex][subRelationShip]) 
              end

            end
            puts "#{__LINE__}|----syntaxLevelFlowVisited[#{syntaxLevelFlowIndex}][#{subRelationShip}]: #{syntaxLevelFlowVisited[syntaxLevelFlowIndex][subRelationShip]}"
            syntaxLevelFlowVisited[syntaxLevelFlowIndex][subRelationShip] = toggle(syntaxLevelFlowVisited[syntaxLevelFlowIndex][subRelationShip]) 
            puts "#{__LINE__}|----syntaxLevelFlowVisited[#{syntaxLevelFlowIndex}][#{subRelationShip}]: #{syntaxLevelFlowVisited[syntaxLevelFlowIndex][subRelationShip]}"
            aux_word = word
            puts "#{__LINE__}|----NewAuxWord:>#{aux_word}<"

          when "loop"
            puts "#{__LINE__}|----loop subrelationShip"
            
          when "R_NA"
            puts "#{__LINE__}|----R_NA subrelationShip"
            if (isTypeOfConst["value"] and !isCompound)
              puts "#{__LINE__}|----- #{word} is #{isTypeOfConst["type"]}"
            end
            if (isTypeOfConst["value"] and isCompound)
              if (!@syntax.isTypeOfConst?(word))
                if (compoundString == "")
                  compoundString = word
                else
                  compoundString = compoundString + " " + word
                end
              end
            end  

          when "BEGIN"
            syntaxLevelFlowVisited[syntaxLevelFlowIndex]["BEGIN"] = true 

          when "END"
            #check if errors
            #if no error decrement levelFlowindex with 1
            syntaxLevelFlowVisited[syntaxLevelFlowIndex]["END"] = true
            syntaxOK = checkIfSyntaxPassed(syntaxLevelFlowVisited[syntaxLevelFlowIndex])
            puts "#{__LINE__}|---- syntaxOK?: #{syntaxOK} #{syntaxLevelFlowVisited[syntaxLevelFlowIndex]}"
#            if !syntaxOK
#              puts "#{__LINE__}|----syntax didn't passed check for canBeMissing"
#              syntaxLevelFlowVisited[syntaxLevelFlowIndex].each do |key, value|
#                puts "#{__LINE__}|----syntaxLevelFlowVisited[syntaxLevelFlowIndex]: #{key} - #{value}"
#                if value == false
#                   puts "#{__LINE__}|----FALSE syntaxLevelFlow[syntaxLevelFlowIndex][#{key}]"
#                   canBeMissing = checkIfRelationCanBeMissing(syntaxLevelFlow[syntaxLevelFlowIndex][key])
#                   puts "#{__LINE__}|----FALSE canBeMissing: #{canBeMissing}"
#                   if !canBeMissing 
#                     return "SYNTAX_ERROR"
#                   end 
#                end   
#              end
#            else
#              puts "#{__LINE__}|---- syntaxOK?: #{syntaxOK}"
#            end
            puts "#{__LINE__}|---- decrementing syntaxLevelFlowIndex: #{syntaxLevelFlowIndex}"
            isTypeOfConst["type"] = ""
            isTypeOfConst["value"] = false
            syntaxWordIndex = 0

          when "0".."9"
            case word
            when "I_VALUE"
            when "S_VALUE"
            when "O_OPEN_CLOSE_COMPOUND"
              isCompound = toggle(isCompound)
              if (!isCompound)
                puts "#{__LINE__}|----COMPOUND word:>#{compoundString}<"
                if (isTypeOfConst["value"])
                  puts "#{__LINE__}|-----#{compoundString} is #{isTypeOfConst["type"]}"
                end
              else
              end
              syntaxLevelFlowVisited[syntaxLevelFlowIndex][subRelationShip] = toggle(syntaxLevelFlowVisited[syntaxLevelFlowIndex][subRelationShip])
            end
            syntaxLevelFlowVisited[syntaxLevelFlowIndex][subRelationShip] = true

          end

          if subRelationShip != "R_NA"
            puts "#{__LINE__}|---syntaxLevelFlow[syntaxLevelFlowIndex].values[syntaxWordIndex] syntaxLevelFlow[#{syntaxLevelFlowIndex}].values[#{syntaxWordIndex}]: #{syntaxLevelFlow[syntaxLevelFlowIndex].values[syntaxWordIndex]} word: #{word}"
            if syntaxLevelFlow[syntaxLevelFlowIndex].values[syntaxWordIndex] != word
              return "SYNTAX_ERROR"
            end

            case subRelationShip 
            when "END"
              syntaxLevelFlowIndex = syntaxLevelFlowIndex - 1
            end

            syntaxWordIndex = syntaxWordIndex + 1
          end

        end #(hasRelationsShips != "R_NA")

        puts "#{__LINE__}|---syntaxLevelFlowVisited: #{syntaxLevelFlowVisited.inspect}"
        word_idx = word_idx + 1

      end
      puts "#{__LINE__}|-CurrentLine: #{line}"
      puts "#{__LINE__}\\fileContent.each_line Inside End LineNumber:#{lineNumber}--------------------------------------------------------------------------------------\n"
    end
  end
end #class SyntaxChecker

end #module RubyScript2CAPLConverter
